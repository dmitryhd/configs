"Vimrc by Dmitry Khodakov - 04.09.14
"
"Here goes list of functions, written partially by me as shortcuts in work
"
if !exists("g:script_args")
    let g:script_args=""
endif

if !exists("g:make_command")
    let g:make_command="export PYTHONPATH=/home/dimert/NMS/nms_app; nosetests -xv --processes=60 --process-timeout=300 --process-restartworker"
endif

if !exists("g:is_console_present")
    let g:is_console_present=0
endif

func! RunReplace()
  let selected = s:get_visual_selection()
  exec "promptrepl " . selected 
endfunc

func! InsertPythonComment()
    "TODO
endfunc

" --- pylint checker 
let g:pylint_onwrite = 0
let g:pylint_show_rate = 0
let g:pylint_cwindow = 0

function! s:get_visual_selection()
  " Why is this not a built-in Vim script function?!
  let [lnum1, col1] = getpos("'<")[1:2]
  let [lnum2, col2] = getpos("'>")[1:2]
  let lines = getline(lnum1, lnum2)
  let lines[-1] = lines[-1][: col2 - (&selection == 'inclusive' ? 1 : 2)]
  let lines[0] = lines[0][col1 - 1:]
  return join(lines, "\n")
endfunction

function! PythonPylintCheck()
  if !exists('g:pylint_cwindow_open')
    let g:pylint_cwindow_open = 0
  endif
  set makeprg=(pylint\ -r\ y\ --reports=n\ --output-format=parseable\ %)
  set errorformat=%f:%l:%m
  if g:pylint_cwindow_open == 1
    exec "ccl"
    let g:pylint_cwindow_open = 0
  else
    exec "make"
    exec "cwindow"
    let g:pylint_cwindow_open = 1
  endif
endfunction

function! SeeCurrentWd()
    exec "e! ."
endfunction

func! MyTagbarSwitch()
  if @% == '__Tagbar__'
    echo 'switching ON tagbar'
    exec ":q"
  else
    echo 'switching OFF tagbar'
    exec "TagbarOpen fjc"
  endif
endfunc

func! SwitchTerm()
  if matchstr(@%, 'bash - ') == 'bash - '
    exec "wincmd h"
    echo 'you in the bash, switch to code'
  else
    exec "wincmd l"
    exec "startinsert"
    echo 'you not in the bash, switch to bash'
  endif
endfunc

func! SwitchToErrorWindow()
  if matchstr(@%, ' ') == 'bash - '
    exec "wincmd h"
    echo 'you in the bash, switch to code'
  else
    exec "wincmd l"
    exec "startinsert"
    echo 'you not in the bash, switch to bash'
  endif
endfunc

func! _CreateNewHorizBuffer()
  exec "40split"
  exec "wincmd j"
  set nocursorline
endfunc

func! _CreateNewConsole()
  f new_console
  let g:is_console_present=1
endfunc

func! _GetRidOfConsole()
  bdelete new_console
  let g:is_console_present=0
endfunc

func! OpenTerm()
  if g:is_console_present == 0
    call _CreateNewHorizBuffer()
    if has ("win32") || has("win16")
      exec "ConqueTerm powershell.exe"
    else
      exec "ConqueTerm bash"
    endif
    call _CreateNewConsole()
  else
    call _GetRidOfConsole()
  endif
endfunc

func! ExecPythonScript(debug)
  if g:is_console_present == 0
    if &filetype == 'python'
      call _CreateNewHorizBuffer()
      if a:debug == 1
        exec "ConqueTerm python3 -i " . expand("%") . ' ' . g:script_args
      else
        exec "ConqueTerm python3 -m pdb " . expand("%")
      endif
      call _CreateNewConsole()
    endif
  else
    call _GetRidOfConsole()
  endif
endfunc

func! RunMakeSequence()
  if g:is_console_present == 0
    call _CreateNewHorizBuffer()
    exec "ConqueTerm bash -c \'" . g:make_command . "\'"
    call _CreateNewConsole()
  else
    call _GetRidOfConsole()
  endif
endfunc

function! BufNewFile_PY()
endfunction

function! BufNewFile_C()
endfunction

function! BufNewFile_CPP()
endfunction

func! PythonAutoPEP8()
  exec "wa"
  exec "!autopep8 -i %"
endfunc

"------------- vim position restore
if has("gui_running")
  function! ScreenFilename()
    if has('amiga')
      return "s:.vimsize"
    elseif has('win32')
      return $HOME.'\_vimsize'
    else
      return $HOME.'/.vimsize'
    endif
  endfunction

  function! ScreenRestore()
    " Restore window size (columns and lines) and position
    " from values stored in vimsize file.
    " Must set font first so columns and lines are based on font size.
    let f = ScreenFilename()
    if has("gui_running") && g:screen_size_restore_pos && filereadable(f)
      let vim_instance = (g:screen_size_by_vim_instance==1?(v:servername):'GVIM')
      for line in readfile(f)
        let sizepos = split(line)
        if len(sizepos) == 5 && sizepos[0] == vim_instance
          silent! execute "set columns=".sizepos[1]." lines=".sizepos[2]
          silent! execute "winpos ".sizepos[3]." ".sizepos[4]
          return
        endif
      endfor
    endif
  endfunction

  function! ScreenSave()
    " Save window size and position.
    if has("gui_running") && g:screen_size_restore_pos
      let vim_instance = (g:screen_size_by_vim_instance==1?(v:servername):'GVIM')
      let data = vim_instance . ' ' . &columns . ' ' . &lines . ' ' .
            \ (getwinposx()<0?0:getwinposx()) . ' ' .
            \ (getwinposy()<0?0:getwinposy())
      let f = ScreenFilename()
      if filereadable(f)
        let lines = readfile(f)
        call filter(lines, "v:val !~ '^" . vim_instance . "\\>'")
        call add(lines, data)
      else
        let lines = [data]
      endif
      call writefile(lines, f)
    endif
  endfunction

  if !exists('g:screen_size_restore_pos')
    let g:screen_size_restore_pos = 1
  endif
  if !exists('g:screen_size_by_vim_instance')
    let g:screen_size_by_vim_instance = 1
  endif
  autocmd VimEnter * if g:screen_size_restore_pos == 1 | call ScreenRestore() | endif
  autocmd VimLeavePre * if g:screen_size_restore_pos == 1 | call ScreenSave() | endif
endif
